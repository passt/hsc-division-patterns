# Function to run LIME variable importances 
# LIME parameters optimized to give good local explanation of model, and consistent interpretations across different cells

library(lime)
library(h2o)
library(gplots) 

localH2O = h2o.init(nthreads=-1)

##############################################################################################################

#import model - model generated by h2o.deeplearning command with parameters specified in the manuscript. 

model.path = "ANN"
model = h2o.loadModel(model.path)

# import PDC data
PDC_data8 <- read.csv("~/Desktop/PDC8.csv", header=FALSE)
PDC_data4 <- read.csv("~/Desktop/PDC4.csv", header=FALSE)
PDC_data18 <- read.csv("~/Desktop/PDCm18.csv", header=FALSE)

PDC_data = rbind(PDC_data4,PDC_data8,PDC_data18)

# import training data
training_data <- read.csv("~/Desktop/TFull.csv", header=FALSE) 
training_data = training_data[,1:96]

P  = predict(model,as.h2o(PDC_data))
P = as.data.frame(P)
L = P$predict
cL = count(L)

UL = cL$x[which(cL$freq >= 50)]

##############################################################################################################

# LIME explainer - 2 bins for interpretability, gene is high or low
explainer <- lime(x = training_data, model = model, n_bins = 2, bin_continuous = TRUE, quantile_bins = FALSE)

##############################################################################################################


# Run explainer on random sample of 20 PDCs from each class

ncells = 20

for (j in 1:length(UL)){
  
  idx = which(L == UL[j],arr.ind = T) 
  NumC = length(idx)
  nc = min(NumC,ncells)
  s = sample(1:NumC,nc)
  
  if (j == 1){
    test_data = PDC_data[idx[s],]
  }
  else{
    temp_data = PDC_data[idx[s],]
    test_data = rbind(temp_data,test_data)
  }
}

nfeatures = 10

explanation <- lime::explain (
  x = as.data.frame(test_data),
  explainer    = explainer, 
  n_features = nfeatures,
  dist_fun = "euclidean",
  kernel_width = 1.3,
  feature_select = "forward_selection",
  n_labels = 1)

idx = which(explanation$model_r2 > 0.25)
explanation = explanation[idx,]

##############################################################################################################
# clean explainer output 

Ftrs = unique(explanation$feature)
nfeat = length(Ftrs)

for (j in 1:nfeat){
  
  st = paste(Ftrs[j],"\\b",sep = "")
  
  idx = which(grepl(st,explanation$feature_desc)) # indicies associated with feature
  U = unique(explanation$feature_desc[idx]) # feature descriptions
  ndesc = length(U) # number of feature descriptions (could be two of them)
  
  for (k in 1:ndesc){
    
    I = which(grepl(U[k],explanation$feature_desc)) # indicies associated with k = 1,2 feature description
    
    if (grepl("V",substring(U[k],1,1)) == TRUE){
      explanation$feature_weight[I] = -explanation$feature_weight[I] # if feature is "less than" switch sign
      
      if (ndesc == 2){
        kswitch = setdiff(c(1,2),k) # switch feature description if alternative "greater than" appears
        explanation$feature_desc[I] = U[kswitch]
      }
      
    }
    
    
  }
}



##############################################################################################################
# most informative features

# explainer renames labels ".' is "+" and "..1" is "-"
ClassLabels = unique(explanation$label)

vectorOfYf <- vector(mode = "list", length = length(ClassLabels))

Mout = matrix(0,length(ClassLabels),nfeatures)

for (j in 1:length(ClassLabels)){
  
  idx = which(explanation$label == ClassLabels[j],arr.ind = T)
  
  nclass_cells = length(unique(explanation$case[idx]))
  
  Xf = explanation$feature_desc[idx]
  Yf <- as.data.frame(sort(table(Xf),decreasing=T))
  Yf[,2] = Yf[,2]/(nclass_cells)
  
  vectorOfYf[[j]] = Yf
  
  d = explanation[idx,] 
  
  v = vectorOfYf[[j]]
  v = v[[1]]
  
  Mouttemp = matrix(0,1,nfeatures)
  
  for (i in 1:nfeatures){
    
    I = which(d$feature_desc == v[i], arr.ind = T)
    Mouttemp[i] = sum(sign(d$feature_weight[I]))#/length(D1$feature_weight[I])
  }
  
  Mout[j,] = Mouttemp
  
}

##############################################################################################################
# Venn diagram

V = venn(list(vectorOfYf[[1]]$Xf[1:nfeatures],vectorOfYf[[2]]$Xf[1:nfeatures],vectorOfYf[[3]]$Xf[1:nfeatures],vectorOfYf[[3]]$Xf[1:nfeatures],vectorOfYf[[3]]$Xf[1:nfeatures]))
